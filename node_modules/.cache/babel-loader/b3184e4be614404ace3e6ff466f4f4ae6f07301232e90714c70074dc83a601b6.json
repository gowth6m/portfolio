{"ast":null,"code":"import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(id, name) {\n  var _window = window,\n    MotionAppearAnimations = _window.MotionAppearAnimations;\n  var animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  var animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n  if (animation) {\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n    sync.render(function () {\n      /**\n       * Animation.cancel() throws so it needs to be wrapped in a try/catch\n       */\n      try {\n        animation.cancel();\n        MotionAppearAnimations.delete(animationId);\n      } catch (e) {}\n    });\n    return animation.currentTime || 0;\n  } else {\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":{"version":3,"names":["sync","transformProps","appearStoreId","handoffOptimizedAppearAnimation","id","name","window","MotionAppearAnimations","animationId","has","animation","get","render","cancel","delete","e","currentTime"],"sources":["/Users/gowtham/Documents/GitHub/portfolio/node_modules/framer-motion/dist/es/animation/optimized-appear/handoff.mjs"],"sourcesContent":["import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(id, name) {\n    const { MotionAppearAnimations } = window;\n    const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n    const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n    if (animation) {\n        /**\n         * We allow the animation to persist until the next frame:\n         *   1. So it continues to play until Framer Motion is ready to render\n         *      (avoiding a potential flash of the element's original state)\n         *   2. As all independent transforms share a single transform animation, stopping\n         *      it synchronously would prevent subsequent transforms from handing off.\n         */\n        sync.render(() => {\n            /**\n             * Animation.cancel() throws so it needs to be wrapped in a try/catch\n             */\n            try {\n                animation.cancel();\n                MotionAppearAnimations.delete(animationId);\n            }\n            catch (e) { }\n        });\n        return animation.currentTime || 0;\n    }\n    else {\n        return 0;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,2BAA2B;AAChD,SAASC,cAAc,QAAQ,uCAAuC;AACtE,SAASC,aAAa,QAAQ,gBAAgB;AAE9C,SAASC,+BAA+B,CAACC,EAAE,EAAEC,IAAI,EAAE;EAC/C,cAAmCC,MAAM;IAAjCC,sBAAsB,WAAtBA,sBAAsB;EAC9B,IAAMC,WAAW,GAAGN,aAAa,CAACE,EAAE,EAAEH,cAAc,CAACQ,GAAG,CAACJ,IAAI,CAAC,GAAG,WAAW,GAAGA,IAAI,CAAC;EACpF,IAAMK,SAAS,GAAGH,sBAAsB,IAAIA,sBAAsB,CAACI,GAAG,CAACH,WAAW,CAAC;EACnF,IAAIE,SAAS,EAAE;IACX;AACR;AACA;AACA;AACA;AACA;AACA;IACQV,IAAI,CAACY,MAAM,CAAC,YAAM;MACd;AACZ;AACA;MACY,IAAI;QACAF,SAAS,CAACG,MAAM,EAAE;QAClBN,sBAAsB,CAACO,MAAM,CAACN,WAAW,CAAC;MAC9C,CAAC,CACD,OAAOO,CAAC,EAAE,CAAE;IAChB,CAAC,CAAC;IACF,OAAOL,SAAS,CAACM,WAAW,IAAI,CAAC;EACrC,CAAC,MACI;IACD,OAAO,CAAC;EACZ;AACJ;AAEA,SAASb,+BAA+B"},"metadata":{},"sourceType":"module","externalDependencies":[]}